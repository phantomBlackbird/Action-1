<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mini World Explorer - Animation Synced Movement</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex; justify-content: center; align-items: center;
            z-index: 2000; transition: opacity 0.5s;
            color: white; text-align: center;
        }
        
        .loading-content {
            background: rgba(0,0,0,0.5); padding: 40px;
            border-radius: 20px; backdrop-filter: blur(10px);
        }
        
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%; border-top-color: #4a9eff;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #loading-status {
            font-size: 18px; margin-top: 20px;
            padding: 10px 20px; background: rgba(74, 158, 255, 0.3);
            border-radius: 30px;
        }
        
        #touch-controls {
            position: fixed; bottom: 30px; left: 0; right: 0;
            display: flex; justify-content: space-between; padding: 20px;
            pointer-events: none; z-index: 1000;
        }
        
        .joystick-area {
            pointer-events: auto; width: 120px; height: 120px;
            background: rgba(30, 30, 50, 0.8); border-radius: 60px;
            backdrop-filter: blur(5px); border: 2px solid #4a9eff;
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
            box-shadow: 0 0 20px rgba(74, 158, 255, 0.3);
        }
        
        .joystick {
            width: 50px; height: 50px; background: white;
            border-radius: 25px; border: 2px solid #4a9eff;
            transition: transform 0.05s;
        }
        
        .action-buttons {
            display: flex; gap: 10px; pointer-events: auto;
            flex-wrap: wrap; justify-content: flex-end;
            max-width: 350px;
        }
        
        .action-btn {
            width: 70px; height: 70px; border-radius: 35px;
            background: rgba(30, 30, 50, 0.8); border: 3px solid #4a9eff;
            color: white; font-size: 12px; font-weight: bold;
            backdrop-filter: blur(5px); cursor: pointer;
            transition: all 0.1s;
            box-shadow: 0 0 15px rgba(74, 158, 255, 0.3);
            touch-action: manipulation;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .action-btn:active { transform: scale(0.95); background: #4a9eff; }
        .action-btn.holding { 
            transform: scale(0.9); 
            background: #ffaa00;
            box-shadow: 0 0 30px #ffaa00;
        }
        
        #jump-btn { border-color: #ffaa00; }
        #shoot-btn { border-color: #ff4757; }
        #grenade-btn { border-color: #9f7aea; }
        #reload-btn { border-color: #4a9eff; }
        
        #hud {
            position: fixed; top: 20px; left: 20px; color: white;
            background: rgba(30, 30, 50, 0.8); padding: 15px 25px;
            border-radius: 10px; backdrop-filter: blur(5px);
            border: 2px solid #4a9eff; z-index: 1000;
        }
        
        #hud .title { font-size: 24px; font-weight: bold; color: #4a9eff; }
        #hud .size { color: #88ff88; }
        
        #anim-status {
            position: fixed; bottom: 200px; left: 50%;
            transform: translateX(-50%);
            color: #4a9eff; font-size: 24px; font-weight: bold;
            background: rgba(30, 30, 50, 0.9); padding: 10px 30px;
            border-radius: 40px; border: 2px solid #4a9eff;
            z-index: 1000; backdrop-filter: blur(5px);
            box-shadow: 0 0 30px rgba(74, 158, 255, 0.5);
            min-width: 200px;
            text-align: center;
        }
        
        #controls-hint {
            position: fixed; bottom: 120px; left: 50%;
            transform: translateX(-50%);
            color: white; background: rgba(30, 30, 50, 0.8);
            padding: 10px 25px; border-radius: 30px;
            border: 1px solid #4a9eff; z-index: 1000;
        }
        
        #rapid-indicator {
            position: fixed; bottom: 300px; right: 20px;
            color: #ffaa00; background: rgba(0,0,0,0.7);
            padding: 5px 10px; border-radius: 20px;
            font-size: 12px; border: 1px solid #ffaa00;
            display: none;
        }
        
        #debug-info {
            position: fixed; top: 80px; right: 20px;
            color: #4a9eff; background: rgba(30, 30, 50, 0.8);
            padding: 8px 15px; border-radius: 20px;
            font-size: 12px; border: 1px solid #4a9eff;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>üåç MINI WORLD EXPLORER</h1>
            <h3>Animation Synced Movement</h3>
            <div class="spinner"></div>
            <div id="loading-status">Loading Player.glb...</div>
        </div>
    </div>

    <div id="hud">
        <div class="title">‚öîÔ∏è MINI EXPLORER</div>
        <div class="size">Size: <span style="color: #88ff88;">3x (0.009 scale)</span></div>
        <div>X: <span id="pos-x">0.0</span> Z: <span id="pos-z">0.0</span></div>
    </div>
    
    <div id="anim-status">IDLE</div>
    <div id="controls-hint">üëÜ Joystick to move | Hold buttons for actions</div>
    <div id="rapid-indicator">üî• RAPID FIRE</div>
    <div id="debug-info">Movement: Animation Synced</div>

    <div id="touch-controls">
        <div class="joystick-area" id="move-joystick">
            <div class="joystick" id="joystick-handle"></div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" id="jump-btn">JUMP</button>
            <button class="action-btn" id="shoot-btn">SHOOT</button>
            <button class="action-btn" id="grenade-btn"> GRENADE</button>
            <button class="action-btn" id="reload-btn">RELOAD</button>
        </div>
    </div>
    
    <a-scene background="color: #87CEEB" shadow="type: pcfsoft" vr-mode-ui="enabled: false" renderer="antialias: true">
        <a-assets>
            <a-asset-item id="player-model" src="Player.glb"></a-asset-item>
            <a-asset-item id="gun-model" src="Mpsd.glb"></a-asset-item>
            <a-asset-item id="ground-model" src="Ground.glb"></a-asset-item>
        </a-assets>

        <!-- Ground Model -->
        <a-gltf-model 
            id="ground" 
            src="#ground-model"
            position="0 0 0"
            scale="1 1 1"
            receive-shadow
            static-body>
        </a-gltf-model>

        <!-- Player -->
        <a-entity id="player" position="0 0.18 0">
            <a-gltf-model 
                id="player-model-instance" 
                src="#player-model"
                scale="0.020 0.020 0.020"
                animation-mixer="clip: idle; loop: repeat; crossFadeDuration: 0.2"
                shadow="cast: true; receive: true">
            </a-gltf-model>
            
            <!-- Gun -->
            <a-entity id="gun" position="0.9 0.9 0.9" rotation="0 90 0" scale="0.0075 0.0075 0.0075">
                <a-gltf-model 
                    id="gun-model-instance" 
                    src="#gun-model"
                    shadow="cast: true; receive: true">
                </a-gltf-model>
            </a-entity>
        </a-entity>

        <!-- Camera -->
        <a-camera id="camera" wasd-controls="enabled: false" look-controls="enabled: true" position="0 1.5 5.0"></a-camera>
        
        <!-- Lighting -->
        <a-light type="ambient" intensity="0.6"></a-light>
        <a-light type="directional" position="2 10 3" intensity="1.5" castshadow="true"></a-light>
        <a-light type="point" position="0 5 5" intensity="1.0"></a-light>
    </a-scene>
    
    <script>
        (function() {
            console.log('Starting Mini World Explorer with Animation Synced Movement...');
            
            // ===== ANIMATION MAPPING (Based on screenshot) =====
            const ANIMATIONS = {
                // Movement animations
                IDLE: 'idle',
                WALK_FORWARD: 'walk-forward',
                WALK_BACKWARDS: 'walk-backwards',
                WALK_LEFT: 'walk-left',
                WALK_RIGHT: 'walk-right',
                RUN_FORWARD: 'run-forward',
                RUN_BACKWARDS: 'run-backwards',
                RUN_LEFT: 'run-left',
                RUN_RIGHT: 'run-right',
                
                // Action animations
                JUMP: 'jump',
                SHOOT_RIFLE: 'shoot-rifle',
                SHOOT_PISTOL: 'shoot-pistol',
                THROW_GRENADE: 'throw-grenade',
                RELOADING: 'reloading',
                HIT_REACTION_1: 'hit-reaction-1',
                HIT_REACTION_2: 'hit-reaction-2',
                
                // Debug
                T_POSE: 't-pose'
            };
            
            // Animation durations (in seconds) - will be updated from actual model
            const ANIMATION_DURATIONS = {
                [ANIMATIONS.WALK_FORWARD]: 1.0,
                [ANIMATIONS.WALK_BACKWARDS]: 1.0,
                [ANIMATIONS.WALK_LEFT]: 1.0,
                [ANIMATIONS.WALK_RIGHT]: 1.0,
                [ANIMATIONS.RUN_FORWARD]: 0.6,
                [ANIMATIONS.RUN_BACKWARDS]: 0.6,
                [ANIMATIONS.RUN_LEFT]: 0.6,
                [ANIMATIONS.RUN_RIGHT]: 0.6,
                [ANIMATIONS.JUMP]: 0.5,
                [ANIMATIONS.SHOOT_RIFLE]: 0.6,
                [ANIMATIONS.SHOOT_PISTOL]: 0.5,
                [ANIMATIONS.THROW_GRENADE]: 0.8,
                [ANIMATIONS.RELOADING]: 0.7,
                [ANIMATIONS.HIT_REACTION_1]: 0.5,
                [ANIMATIONS.HIT_REACTION_2]: 0.5
            };
            
            // Blacklist
            const BLACKLIST_ANIMATIONS = [ANIMATIONS.T_POSE];
            
            // ===== DOM Elements =====
            const loadingScreen = document.getElementById('loading-screen');
            const loadingStatus = document.getElementById('loading-status');
            const animStatus = document.getElementById('anim-status');
            const rapidIndicator = document.getElementById('rapid-indicator');
            const debugInfo = document.getElementById('debug-info');
            const posX = document.getElementById('pos-x');
            const posZ = document.getElementById('pos-z');
            
            // ===== Button Elements =====
            const jumpBtn = document.getElementById('jump-btn');
            const shootBtn = document.getElementById('shoot-btn');
            const grenadeBtn = document.getElementById('grenade-btn');
            const reloadBtn = document.getElementById('reload-btn');
            
            // ===== State =====
            let joystickActive = false;
            let joystickX = 0;
            let joystickY = 0;
            
            // Button hold states
            let jumpActive = false;
            let shootingActive = false;
            let grenadeActive = false;
            let reloadActive = false;
            
            // Intervals
            let jumpInterval = null;
            let shootInterval = null;
            let grenadeInterval = null;
            let reloadInterval = null;
            
            // Movement speed - CALCULATED based on animation duration
            // For a 1-second walk cycle, we want to move a certain distance
            const WALK_DISTANCE_PER_CYCLE = 0.3; // Distance covered in one walk cycle
            const RUN_DISTANCE_PER_CYCLE = 0.5;  // Distance covered in one run cycle
            
            // These will be calculated once we know actual animation durations
            let WALK_SPEED = 0.3;  // Default, will be adjusted
            let RUN_SPEED = 0.83;   // Default, will be adjusted
            
            // Rapid fire settings
            const RAPID_FIRE_DELAY = 100;
            const JUMP_DELAY = 400;
            const GRENADE_DELAY = 300;
            const RELOAD_DELAY = 700;
            
            // Jump settings
            const JUMP_HEIGHT = 0.24;
            const GROUND_LEVEL = 0.18;
            
            // ===== A-Frame Elements =====
            const scene = document.querySelector('a-scene');
            const player = document.getElementById('player');
            const camera = document.getElementById('camera');
            const playerModel = document.getElementById('player-model-instance');
            const gunModel = document.getElementById('gun-model-instance');
            
            // Track animation state
            let currentAnim = ANIMATIONS.IDLE;
            let animationMixer = null;
            
            // ===== Animation Speed Calculator =====
            function updateMovementSpeedFromAnimations() {
                // Get actual animation durations from the model
                if (animationMixer && animationMixer.clips) {
                    animationMixer.clips.forEach(clip => {
                        const duration = clip.duration;
                        const name = clip.name;
                        
                        // Update durations in our map
                        if (ANIMATION_DURATIONS.hasOwnProperty(name)) {
                            ANIMATION_DURATIONS[name] = duration;
                            console.log(`Animation ${name} duration: ${duration}s`);
                        }
                    });
                    
                    // Calculate speeds based on actual animation durations
                    const walkDuration = ANIMATION_DURATIONS[ANIMATIONS.WALK_FORWARD] || 1.0;
                    const runDuration = ANIMATION_DURATIONS[ANIMATIONS.RUN_FORWARD] || 0.6;
                    
                    WALK_SPEED = WALK_DISTANCE_PER_CYCLE / walkDuration;
                    RUN_SPEED = RUN_DISTANCE_PER_CYCLE / runDuration;
                    
                    console.log(`Calculated speeds - Walk: ${WALK_SPEED}, Run: ${RUN_SPEED}`);
                    
                    debugInfo.innerHTML = `Walk: ${WALK_SPEED.toFixed(3)}/s<br>Run: ${RUN_SPEED.toFixed(3)}/s`;
                }
            }
            
            // ===== Safe Animation Function =====
            function setSafeAnimation(animName, loopType = 'repeat', playOnce = false) {
                if (!playerModel) return;
                
                // NEVER play blacklisted animations
                if (BLACKLIST_ANIMATIONS.includes(animName)) {
                    console.warn('Blocked blacklisted animation:', animName);
                    animName = ANIMATIONS.IDLE;
                }
                
                // Don't re-set the same looping animation
                if (currentAnim === animName && loopType === 'repeat' && !playOnce) {
                    return;
                }
                
                // Update UI
                let displayName = animName.toUpperCase();
                if (animName === ANIMATIONS.IDLE) displayName = 'IDLE';
                else if (animName === ANIMATIONS.RUN_FORWARD) displayName = 'üèÉ RUNNING';
                else if (animName === ANIMATIONS.WALK_FORWARD) displayName = 'üö∂ WALKING';
                else if (animName.includes('run')) displayName = 'üèÉ ' + animName.replace('run-', '').toUpperCase();
                else if (animName.includes('walk')) displayName = 'üö∂ ' + animName.replace('walk-', '').toUpperCase();
                else if (animName === ANIMATIONS.SHOOT_RIFLE) displayName = 'üî´ SHOOTING';
                else if (animName === ANIMATIONS.JUMP) displayName = 'ü¶ò JUMPING';
                else if (animName === ANIMATIONS.THROW_GRENADE) displayName = 'üí£ GRENADE';
                else if (animName === ANIMATIONS.RELOADING) displayName = 'üîÑ RELOADING';
                else if (animName.includes('hit')) displayName = 'üí• HIT';
                
                animStatus.textContent = displayName;
                currentAnim = animName;
                
                try {
                    playerModel.setAttribute('animation-mixer', {
                        clip: animName,
                        loop: loopType,
                        crossFadeDuration: 0.2,
                        timeScale: 1.0
                    });
                } catch (e) {
                    console.warn('Could not play animation:', animName);
                }
            }
            
            // ===== Movement Animation Selection =====
            function getMovementAnimation() {
                if (!joystickActive) return ANIMATIONS.IDLE;
                
                const magnitude = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
                if (magnitude < 0.1) return ANIMATIONS.IDLE;
                
                const isRunning = magnitude > 0.7;
                
                // Determine primary direction
                if (Math.abs(joystickX) > Math.abs(joystickY)) {
                    // Strafe left/right
                    return joystickX > 0 
                        ? (isRunning ? ANIMATIONS.RUN_RIGHT : ANIMATIONS.WALK_RIGHT)
                        : (isRunning ? ANIMATIONS.RUN_LEFT : ANIMATIONS.WALK_LEFT);
                } else {
                    // Forward/backward
                    return joystickY > 0 
                        ? (isRunning ? ANIMATIONS.RUN_FORWARD : ANIMATIONS.WALK_FORWARD)
                        : (isRunning ? ANIMATIONS.RUN_BACKWARDS : ANIMATIONS.WALK_BACKWARDS);
                }
            }
            
            // ===== Jump Function =====
            function performJump() {
                if (!player) return;
                
                setSafeAnimation(ANIMATIONS.JUMP,'repeat', true);
                
                const startY = player.getAttribute('position').y;
                const jumpStart = Date.now();
                const JUMP_DURATION = (ANIMATION_DURATIONS[ANIMATIONS.JUMP] || 0.5) * 1000;
                
                function animateJump() {
                    const elapsed = Date.now() - jumpStart;
                    const progress = Math.min(elapsed / JUMP_DURATION, 1);
                    
                    if (progress >= 1) {
                        const pos = player.getAttribute('position');
                        pos.y = GROUND_LEVEL;
                        player.setAttribute('position', pos);
                        return;
                    }
                    
                    const jumpProgress = Math.sin(progress * Math.PI);
                    const pos = player.getAttribute('position');
                    pos.y = startY + (JUMP_HEIGHT * jumpProgress);
                    player.setAttribute('position', pos);
                    
                    requestAnimationFrame(animateJump);
                }
                
                animateJump();
            }
            
            // ===== Action Functions =====
            function startJumping() {
                if (jumpActive) return;
                jumpActive = true;
                jumpBtn.classList.add('holding');
                performJump();
                jumpInterval = setInterval(() => {
                    if (jumpActive) performJump();
                }, JUMP_DELAY);
            }
            
            function stopJumping() {
                jumpActive = false;
                jumpBtn.classList.remove('holding');
                if (jumpInterval) {
                    clearInterval(jumpInterval);
                    jumpInterval = null;
                }
                updatePostActionAnimation();
            }
            
            function startShooting() {
                if (shootingActive) return;
                shootingActive = true;
                shootBtn.classList.add('holding');
                rapidIndicator.style.display = 'block';
                setSafeAnimation(ANIMATIONS.SHOOT_RIFLE, 'repeat');
                
                if (gunModel) {
                    shootInterval = setInterval(() => {
                        if (!shootingActive) return;
                        gunModel.setAttribute('material', 'emissive', '#FF5500');
                        gunModel.setAttribute('material', 'emissiveIntensity', '2.0');
                        setTimeout(() => {
                            if (shootingActive) {
                                gunModel.setAttribute('material', 'emissive', '#000000');
                                gunModel.setAttribute('material', 'emissiveIntensity', '0');
                            }
                        }, 50);
                    }, RAPID_FIRE_DELAY);
                }
            }
            
            function stopShooting() {
                shootingActive = false;
                shootBtn.classList.remove('holding');
                rapidIndicator.style.display = 'none';
                if (shootInterval) {
                    clearInterval(shootInterval);
                    shootInterval = null;
                }
                if (gunModel) {
                    gunModel.setAttribute('material', 'emissive', '#000000');
                }
                updatePostActionAnimation();
            }
            
            function startGrenade() {
                if (grenadeActive) return;
                grenadeActive = true;
                grenadeBtn.classList.add('holding');
                setSafeAnimation(ANIMATIONS.THROW_GRENADE, 'repeat');
                
                grenadeInterval = setInterval(() => {
                    if (!grenadeActive) return;
                    gunModel?.setAttribute('material', 'emissive', '#9f7aea');
                    gunModel?.setAttribute('material', 'emissiveIntensity', '1.0');
                    setTimeout(() => {
                        if (grenadeActive) {
                            gunModel?.setAttribute('material', 'emissive', '#000000');
                        }
                    }, 50);
                }, GRENADE_DELAY);
            }
            
            function stopGrenade() {
                grenadeActive = false;
                grenadeBtn.classList.remove('holding');
                if (grenadeInterval) {
                    clearInterval(grenadeInterval);
                    grenadeInterval = null;
                }
                if (gunModel) {
                    gunModel.setAttribute('material', 'emissive', '#000000');
                }
                updatePostActionAnimation();
            }
            
            function startReload() {
                if (reloadActive) return;
                reloadActive = true;
                reloadBtn.classList.add('holding');
                setSafeAnimation(ANIMATIONS.RELOADING, 'repeat');
                
                reloadInterval = setInterval(() => {
                    if (!reloadActive) return;
                    // Visual feedback for reload
                    gunModel?.setAttribute('material', 'emissive', '#4a9eff');
                    gunModel?.setAttribute('material', 'emissiveIntensity', '1.0');
                    setTimeout(() => {
                        if (reloadActive) {
                            gunModel?.setAttribute('material', 'emissive', '#000000');
                        }
                    }, 100);
                }, RELOAD_DELAY);
            }
            
            function stopReload() {
                reloadActive = false;
                reloadBtn.classList.remove('holding');
                if (reloadInterval) {
                    clearInterval(reloadInterval);
                    reloadInterval = null;
                }
                if (gunModel) {
                    gunModel.setAttribute('material', 'emissive', '#000000');
                }
                updatePostActionAnimation();
            }
            
            function updatePostActionAnimation() {
                if (jumpActive) {
                    setSafeAnimation(ANIMATIONS.JUMP, 'repeat');
                } else if (shootingActive) {
                    setSafeAnimation(ANIMATIONS.SHOOT_RIFLE, 'repeat');
                } else if (grenadeActive) {
                    setSafeAnimation(ANIMATIONS.THROW_GRENADE, 'repeat');
                } else if (reloadActive) {
                    setSafeAnimation(ANIMATIONS.RELOADING, 'repeat');
                } else if (joystickActive) {
                    const anim = getMovementAnimation();
                    setSafeAnimation(anim, 'repeat');
                } else {
                    setSafeAnimation(ANIMATIONS.IDLE, 'repeat');
                }
            }
            
            // ===== Joystick Setup =====
            const moveJoystick = document.getElementById('move-joystick');
            const joystickHandle = document.getElementById('joystick-handle');
            
            moveJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e.touches[0]);
            });
            
            moveJoystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    updateJoystick(e.touches[0]);
                }
            });
            
            moveJoystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickX = 0;
                joystickY = 0;
                joystickHandle.style.transform = 'translate(0px, 0px)';
                
                if (!jumpActive && !shootingActive && !grenadeActive && !reloadActive) {
                    setSafeAnimation(ANIMATIONS.IDLE, 'repeat');
                }
            });
            
            function updateJoystick(touch) {
                const rect = moveJoystick.getBoundingClientRect();
                const centerX = rect.left + rect.width/2;
                const centerY = rect.top + rect.height/2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const maxDistance = 40;
                const distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
                
                if (distance > maxDistance) {
                    deltaX = (deltaX/distance) * maxDistance;
                    deltaY = (deltaY/distance) * maxDistance;
                }
                
                joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                joystickX = deltaX / maxDistance;
                joystickY = deltaY / maxDistance;
                
                // Update animation if not doing actions
                if (!jumpActive && !shootingActive && !grenadeActive && !reloadActive) {
                    const anim = getMovementAnimation();
                    setSafeAnimation(anim, 'repeat');
                }
            }
            
            // ===== Button Setup =====
            jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startJumping(); });
            jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopJumping(); });
            jumpBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); stopJumping(); });
            
            shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startShooting(); });
            shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopShooting(); });
            shootBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); stopShooting(); });
            
            grenadeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startGrenade(); });
            grenadeBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopGrenade(); });
            grenadeBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); stopGrenade(); });
            
            reloadBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startReload(); });
            reloadBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopReload(); });
            reloadBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); stopReload(); });
            
            // ===== FIXED MOVEMENT SYSTEM =====
            function movePlayer() {
                if (!joystickActive || !player || !camera) return;
                
                // Get current position and rotation
                const playerPos = player.getAttribute('position');
                const cameraRot = camera.getAttribute('rotation');
                
                // Convert rotation to radians
                const radY = THREE.MathUtils.degToRad(cameraRot.y);
                
                // Calculate movement magnitude
                const magnitude = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
                if (magnitude < 0.1) return; // Dead zone
                
                // Determine if running or walking
                const isRunning = magnitude > 0.7;
                const speed = isRunning ? RUN_SPEED : WALK_SPEED;
                
                // Calculate movement direction based on camera
                // Forward/back relative to camera (joystick Y)
                const moveX = (Math.sin(radY) * joystickY + Math.sin(radY + Math.PI/2) * joystickX) * speed * 0.016; // 0.016 = ~1/60 for frame rate independence
                const moveZ = (Math.cos(radY) * joystickY + Math.cos(radY + Math.PI/2) * joystickX) * speed * 0.016;
                
                // Apply movement
                playerPos.x += moveX;
                playerPos.z += moveZ;
                
                // Keep in bounds
                playerPos.x = Math.max(-45, Math.min(45, playerPos.x));
                playerPos.z = Math.max(-45, Math.min(45, playerPos.z));
                
                player.setAttribute('position', playerPos);
                
                // Rotate player to face movement direction (smoothly)
                if (Math.abs(moveX) > 0.0001 || Math.abs(moveZ) > 0.0001) {
                    const targetAngle = Math.atan2(moveX, moveZ);
                    const targetDeg = THREE.MathUtils.radToDeg(targetAngle);
                    
                    const currentRot = player.getAttribute('rotation') || {x: 0, y: 0, z: 0};
                    let currentY = currentRot.y;
                    
                    // Find shortest rotation path
                    let diff = targetDeg - currentY;
                    while (diff > 180) diff -= 360;
                    while (diff < -180) diff += 360;
                    
                    // Apply smooth rotation
                    const newY = currentY + diff * 0.15;
                    player.setAttribute('rotation', {x: 0, y: newY, z: 0});
                }
                
                // Update HUD
                if (posX) posX.textContent = Math.round(playerPos.x * 10) / 10;
                if (posZ) posZ.textContent = Math.round(playerPos.z * 10) / 10;
            }
            
            // ===== CAMERA FOLLOW =====
            function updateCamera() {
                if (!player || !camera) return;
                
                const playerPos = player.getAttribute('position');
                
                // Smooth camera follow
                const currentCamPos = camera.getAttribute('position');
                const targetCamPos = {
                    x: playerPos.x,
                    y: playerPos.y + 1.5,
                    z: playerPos.z + 5.0
                };
                
                // Smooth interpolation
                currentCamPos.x += (targetCamPos.x - currentCamPos.x) * 0.1;
                currentCamPos.y += (targetCamPos.y - currentCamPos.y) * 0.1;
                currentCamPos.z += (targetCamPos.z - currentCamPos.z) * 0.1;
                
                camera.setAttribute('position', currentCamPos);
                
                // Look at player
                const cameraObj = camera.object3D;
                const playerObj = player.object3D;
                
                if (cameraObj && playerObj) {
                    cameraObj.lookAt(playerObj.position);
                }
            }
            
            // ===== Model Loading =====
            let modelsLoaded = 0;
            const totalModels = 3;
            
            if (playerModel) {
                playerModel.addEventListener('model-loaded', () => {
                    console.log('‚úÖ Player model loaded');
                    modelsLoaded++;
                    loadingStatus.textContent = `Loading models... (${modelsLoaded}/${totalModels})`;
                    
                    // Get animation mixer and durations
                    setTimeout(() => {
                        try {
                            const mixerComponent = playerModel.components['animation-mixer'];
                            if (mixerComponent && mixerComponent.mixer) {
                                animationMixer = mixerComponent.mixer;
                                if (animationMixer.clips) {
                                    console.log('Available animations:');
                                    animationMixer.clips.forEach(clip => {
                                        console.log(` - ${clip.name}: ${clip.duration.toFixed(2)}s`);
                                        
                                        // Update durations
                                        if (ANIMATION_DURATIONS.hasOwnProperty(clip.name)) {
                                            ANIMATION_DURATIONS[clip.name] = clip.duration;
                                        }
                                        
                                        // Blacklist t-pose
                                        if (clip.name.toLowerCase().includes('pose')) {
                                            if (!BLACKLIST_ANIMATIONS.includes(clip.name)) {
                                                BLACKLIST_ANIMATIONS.push(clip.name);
                                            }
                                        }
                                    });
                                    
                                    // Calculate movement speeds based on actual animation durations
                                    updateMovementSpeedFromAnimations();
                                }
                            }
                        } catch(e) {
                            console.warn('Could not get animation durations:', e);
                        }
                    }, 1000);
                    
                    checkAllLoaded();
                });
                
                playerModel.addEventListener('error', () => {
                    modelsLoaded++;
                    checkAllLoaded();
                });
            }
            
            if (gunModel) {
                gunModel.addEventListener('model-loaded', () => {
                    console.log('‚úÖ Gun model loaded');
                    modelsLoaded++;
                    loadingStatus.textContent = `Loading models... (${modelsLoaded}/${totalModels})`;
                    gunModel.setAttribute('visible', 'true');
                    checkAllLoaded();
                });
                
                gunModel.addEventListener('error', () => {
                    modelsLoaded++;
                    checkAllLoaded();
                });
            }
            
            const groundModel = document.getElementById('ground');
            if (groundModel) {
                groundModel.addEventListener('model-loaded', () => {
                    console.log('‚úÖ Ground model loaded');
                    modelsLoaded++;
                    loadingStatus.textContent = `Loading models... (${modelsLoaded}/${totalModels})`;
                    checkAllLoaded();
                });
                
                groundModel.addEventListener('error', () => {
                    modelsLoaded++;
                    checkAllLoaded();
                });
            }
            
            function checkAllLoaded() {
                if (modelsLoaded >= totalModels) {
                    loadingStatus.textContent = '‚ú® World ready!';
                    
                    setTimeout(() => {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                        }, 500);
                    }, 1000);
                    
                    setSafeAnimation(ANIMATIONS.IDLE, 'repeat');
                }
            }
            
            // ===== Game Loop =====
            let lastFrameTime = 0;
            
            function gameLoop(currentTime) {
                if (!lastFrameTime) lastFrameTime = currentTime;
                const deltaTime = currentTime - lastFrameTime;
                
                // Only update if delta time is reasonable
                if (deltaTime < 100) {
                    movePlayer();
                    updateCamera();
                }
                
                lastFrameTime = currentTime;
                requestAnimationFrame(gameLoop);
            }
            
            scene.addEventListener('loaded', () => {
                console.log('Scene loaded');
                requestAnimationFrame(gameLoop);
            });
        })();
    </script>
</body>
    </html>
