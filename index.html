<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mini World Explorer - Enhanced Edition</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }
        
        .loading-content {
            text-align: center;
            color: white;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-status {
            font-size: 18px;
            margin-top: 20px;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 30px;
        }
        
        /* Touch Controls */
        #touch-controls {
            position: fixed;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 20px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .joystick-area {
            pointer-events: auto;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 60px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            transition: transform 0.1s;
        }
        
        .joystick-area:active {
            transform: scale(0.95);
        }
        
        .joystick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 25px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.05s ease-out;
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 300px;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 35px;
            background: rgba(0, 150, 255, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.8);
            color: white;
            font-size: 14px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .action-btn:active {
            transform: scale(0.9);
            filter: brightness(1.2);
        }
        
        #jump-btn {
            background: rgba(255, 100, 0, 0.7);
        }
        
        #shoot-btn {
            background: rgba(255, 50, 50, 0.7);
        }
        
        #grenade-btn {
            background: rgba(150, 50, 150, 0.7);
        }
        
        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 2px black;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            line-height: 1.6;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #hud .title {
            font-size: 24px;
            font-weight: bold;
            color: #ffaa00;
            margin-bottom: 5px;
        }
        
        #hud .size {
            color: #88ff88;
        }
        
        #hud .position {
            color: #88aaff;
        }
        
        #anim-status {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffaa00;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 40px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 2px;
            border: 2px solid rgba(255, 170, 0, 0.5);
        }
        
        #controls-hint {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            background: rgba(0,0,0,0.5);
            padding: 10px 25px;
            border-radius: 30px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            text-align: center;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        #debug-toast {
            position: fixed;
            bottom: 300px;
            right: 20px;
            color: #ffaa00;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            border: 1px solid #ffaa00;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <h1>Mini World Explorer</h1>
            <div class="spinner"></div>
            <div class="loading-status" id="loading-status">Loading models...</div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="title">‚öîÔ∏è MINI EXPLORER</div>
        <div class="size">Scale: <span style="color: #88ff88;">0.0030</span></div>
        <div class="position">Position: <span id="pos-x">0.0</span>, <span id="pos-y">0.06</span>, <span id="pos-z">0.0</span></div>
    </div>
    
    <div id="anim-status">IDLE</div>
    <div id="controls-hint">üëÜ Use joystick to move | Buttons for actions</div>
    <div id="debug-toast" style="opacity: 0;">System Ready</div>

    <!-- Mobile Touch Controls -->
    <div id="touch-controls">
        <div class="joystick-area" id="move-joystick">
            <div class="joystick" id="joystick-handle"></div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" id="jump-btn">ü¶ò JUMP</button>
            <button class="action-btn" id="shoot-btn">üî´ SHOOT</button>
            <button class="action-btn" id="grenade-btn">üí£ GRENADE</button>
        </div>
    </div>
    
    <!-- A-Frame Scene -->
    <a-scene background="color: #87CEEB" shadow="type: pcfsoft" vr-mode-ui="enabled: false" renderer="antialias: true; colorManagement: true;">
        <!-- Assets with fallbacks -->
        <a-assets>
            <!-- Primary Models with timeout fallbacks -->
            <a-asset-item id="player-model" src="Player.glb" response-type="arraybuffer"></a-asset-item>
            <a-asset-item id="gun-model" src="Mpsd.glb" response-type="arraybuffer"></a-asset-item>
            
            <!-- Fallback Models (primitive shapes if GLB fails) -->
            <a-asset-item id="fallback-player" src="https://cdn.aframe.io/aframe-brand/examples/player.glb"></a-asset-item>
            
            <!-- Environment Textures -->
            <img id="ground-texture" src="https://cdn.aframe.io/aframe-brand/examples/ground.jpg" crossorigin="anonymous">
            <img id="sky-texture" src="https://cdn.aframe.io/360-image-gallery-boilerplate/img/panorama.jpg" crossorigin="anonymous" crossorigin="anonymous">
        </a-assets>

        <!-- Camera Follow Rig - Enhanced smooth follow system -->
        <a-entity id="camera-follow-rig">
            <!-- Player Character (moves in world space) -->
            <a-entity id="player" position="0 0.06 0">
                <!-- Player Model with animation mixer -->
                <a-gltf-model 
                    id="player-model-instance" 
                    src="#player-model"
                    scale="0.0030 0.0030 0.0030" 
                    position="0 0 0"
                    animation-mixer="clip: idle; loop: repeat; timeScale: 1;"
                    visible="true">
                </a-gltf-model>
                
                <!-- Gun Holder (will be attached to bone) -->
                <a-entity id="gun-holder">
                    <a-gltf-model 
                        id="gun-model-instance" 
                        src="#gun-model" 
                        scale="0.0025 0.0025 0.0025"
                        position="0 0 0"
                        rotation="0 0 0"
                        material="color: #FFAA00; emissive: #442200; emissiveIntensity: 0.5; metalness: 0.7; roughness: 0.3"
                        shadow="cast: true; receive: true"
                        visible="false">
                    </a-gltf-model>
                </a-entity>
                
                <!-- Player shadow -->
                <a-circle 
                    position="0 -0.02 0" 
                    rotation="-90 0 0" 
                    radius="0.02" 
                    color="#333" 
                    material="opacity: 0.3; transparent: true"
                    shadow="receive: false">
                </a-circle>
            </a-entity>
            
            <!-- Camera (positioned relative to follow rig) -->
            <a-entity id="camera-rig" position="0 0.3 0.6">
                <a-camera 
                    id="camera" 
                    wasd-controls="enabled: false" 
                    look-controls="enabled: true; pointerLockEnabled: false"
                    active="true"
                    far="1000">
                </a-camera>
            </a-entity>
        </a-entity>
        
        <!-- Enhanced Lighting -->
        <a-light type="ambient" color="#fff" intensity="0.8"></a-light>
        <a-light type="directional" position="2 5 3" intensity="1.5" castshadow="true" shadow-mapSize-width="2048" shadow-mapSize-height="2048"></a-light>
        <a-light type="point" position="0 3 0" intensity="0.8" color="#FFEECC"></a-light>
        
        <!-- Environment -->
        <a-plane id="ground" rotation="-90 0 0" width="200" height="200" material="src: #ground-texture; repeat: 40 40; roughness: 0.8; metalness: 0.1" receive-shadow></a-plane>
        <a-grid position="0 0.01 0" width="200" height="200" cell-size="1" material="color: #888; opacity: 0.15"></a-grid>
        
        <!-- Decorative elements (optimized with instancing where possible) -->
        <a-entity position="-15 0.1 -20">
            <a-cylinder radius="0.4" height="0.8" color="#8B4513" shadow></a-cylinder>
            <a-sphere position="0 0.6 0" radius="0.6" color="#FF6B6B" shadow></a-sphere>
            <a-sphere position="0.5 1.0 -0.5" radius="0.3" color="#FF8E8E" shadow></a-sphere>
        </a-entity>
        
        <a-entity position="20 0.1 -15">
            <a-cylinder radius="0.5" height="1.0" color="#8B4513" shadow></a-cylinder>
            <a-sphere position="0 0.7 0" radius="0.7" color="#4ECDC4" shadow></a-sphere>
        </a-entity>
        
        <a-entity position="-25 0.2 -30">
            <a-box width="3" height="0.4" depth="3" color="#A0522D" shadow></a-box>
            <a-box position="0 0.8 0" width="2.5" height="1.2" depth="2.5" color="#DEB887" shadow></a-box>
            <a-cone position="0 1.6 0" radius-bottom="1.5" radius-top="0" height="1.2" color="#8B4513" shadow></a-cone>
        </a-entity>
        
        <a-entity position="30 0.1 20">
            <a-cylinder radius="0.3" height="1.5" color="#FF69B4" shadow></a-cylinder>
            <a-cone position="0 1.0 0" radius-bottom="0.4" radius-top="0" height="0.8" color="#FF1493" shadow></a-cone>
        </a-entity>
        
        <a-circle position="10 0.05 40" rotation="-90 0 0" radius="3" color="#4169E1" material="opacity: 0.6; transparent: true"></a-circle>
        
        <!-- Stepping stones (optimized as children of a container) -->
        <a-entity id="stepping-stones" position="0 0 0">
            <a-cylinder position="8 0.1 38" radius="0.4" height="0.1" color="#D3D3D3" shadow></a-cylinder>
            <a-cylinder position="10 0.1 36" radius="0.4" height="0.1" color="#D3D3D3" shadow></a-cylinder>
            <a-cylinder position="12 0.1 38" radius="0.4" height="0.1" color="#D3D3D3" shadow></a-cylinder>
        </a-entity>
    </a-scene>
    
    <script>
        (function() {
            'use strict';
            
            // ============== CONFIGURATION ==============
            const CONFIG = {
                // Player settings
                PLAYER_SCALE: 0.0030,
                PLAYER_HEIGHT: 0.06,
                WALK_SPEED: 0.015,
                RUN_SPEED: 0.025,
                JUMP_HEIGHT: 0.06,
                JUMP_DURATION: 400,
                
                // Camera follow settings
                CAMERA_OFFSET: { x: 0, y: 0.3, z: 0.6 },
                CAMERA_SMOOTHING: 0.1, // Lower = smoother but more lag (0.05-0.2 ideal)
                
                // Bone names to try (in order of preference)
                BONE_NAMES: [
                    'maximorigRightHand',
                    'RightHand',
                    'hand_r',
                    'RightHandIndex1',
                    'mixamorigRightHand',
                    'Bip001 R Hand',
                    'R_Hand',
                    'hand_R'
                ],
                
                // Animation durations (will be updated from actual clips)
                ANIMATION_DEFAULTS: {
                    'jump': 400,
                    'throw-grenade': 800,
                    'shoot-rifle': 500,
                    'shoot-pistol': 400,
                    'reloading': 600,
                    'hit-reaction-1': 500,
                    'hit-reaction-2': 500
                }
            };
            
            // ============== GLOBAL STATE ==============
            const State = {
                gameRunning: true,
                joystickActive: false,
                joystickVector: { x: 0, y: 0 },
                isJumping: false,
                isGrounded: true,
                currentAnimation: 'idle',
                lastMovementTime: Date.now(),
                movementThreshold: 100,
                modelsLoaded: { player: false, gun: false },
                boneAttached: false,
                cameraTarget: new THREE.Vector3(),
                cameraCurrent: new THREE.Vector3(),
                loadingComplete: false,
                animationClips: new Set(),
                groundLevel: 0.06 // Default ground level
            };
            
            // ============== DOM ELEMENTS ==============
            const DOM = {
                loadingScreen: document.getElementById('loading-screen'),
                loadingStatus: document.getElementById('loading-status'),
                debugToast: document.getElementById('debug-toast'),
                posX: document.getElementById('pos-x'),
                posY: document.getElementById('pos-y'),
                posZ: document.getElementById('pos-z'),
                animStatus: document.getElementById('anim-status'),
                moveJoystick: document.getElementById('move-joystick'),
                joystickHandle: document.getElementById('joystick-handle'),
                jumpBtn: document.getElementById('jump-btn'),
                shootBtn: document.getElementById('shoot-btn'),
                grenadeBtn: document.getElementById('grenade-btn')
            };
            
            // ============== A-FRAME ELEMENTS (populated later) ==============
            const Elements = {
                scene: null,
                camera: null,
                player: null,
                playerModel: null,
                gunHolder: null,
                gunModel: null,
                followRig: null,
                cameraRig: null
            };
            
            // ============== UTILITY FUNCTIONS ==============
            function showToast(message, duration = 2000) {
                if (!DOM.debugToast) return;
                DOM.debugToast.style.opacity = '1';
                DOM.debugToast.textContent = message;
                setTimeout(() => {
                    DOM.debugToast.style.opacity = '0';
                }, duration);
            }
            
            function updateLoadingStatus(message) {
                if (DOM.loadingStatus) {
                    DOM.loadingStatus.textContent = message;
                }
            }
            
            function hideLoadingScreen() {
                if (DOM.loadingScreen) {
                    DOM.loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        DOM.loadingScreen.style.display = 'none';
                    }, 500);
                }
            }
            
            // ============== BONE CONSTRAINT COMPONENT (Enhanced) ==============
            AFRAME.registerComponent('enhanced-bone-constraint', {
                schema: {
                    target: { type: 'selector' },
                    boneNames: { type: 'array', default: CONFIG.BONE_NAMES },
                    offset: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
                    rotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
                },
                
                init: function () {
                    this.bone = null;
                    this.targetModel = this.data.target;
                    this.originalParent = this.el.object3D.parent;
                    this.retryCount = 0;
                    this.maxRetries = 10;
                    
                    if (!this.targetModel) {
                        console.error('Enhanced bone constraint: target model not found');
                        return;
                    }
                    
                    // Check if model already loaded
                    this.checkModelLoaded();
                    
                    // Listen for model load
                    this.targetModel.addEventListener('model-loaded', () => {
                        this.setupBone();
                    });
                    
                    // Also listen for object3dset which might fire earlier
                    this.targetModel.addEventListener('object3dset', () => {
                        setTimeout(() => this.setupBone(), 100);
                    });
                },
                
                checkModelLoaded: function() {
                    if (this.targetModel.components['gltf-model'] && 
                        this.targetModel.getObject3D('mesh')) {
                        setTimeout(() => this.setupBone(), 200);
                    } else {
                        // Retry a few times
                        if (this.retryCount < this.maxRetries) {
                            this.retryCount++;
                            setTimeout(() => this.checkModelLoaded(), 500);
                        }
                    }
                },
                
                setupBone: function () {
                    const model = this.targetModel.getObject3D('mesh');
                    if (!model) {
                        console.warn('Enhanced bone constraint: model mesh not found');
                        return;
                    }
                    
                    // Try each bone name
                    for (const boneName of this.data.boneNames) {
                        let found = false;
                        model.traverse((node) => {
                            if (node.isBone && node.name === boneName) {
                                this.bone = node;
                                console.log('Found bone:', node.name);
                                found = true;
                                
                                // Attach to bone
                                this.attachToBone();
                                return;
                            }
                        });
                        if (found) break;
                    }
                    
                    if (!this.bone) {
                        console.warn('No matching bone found. Available bones:');
                        model.traverse((node) => {
                            if (node.isBone) {
                                console.log('Available bone:', node.name);
                            }
                        });
                        
                        // Fallback: attach to model root with offset
                        console.log('Using fallback attachment to model root');
                        this.bone = model;
                        this.attachToBone();
                    }
                },
                
                attachToBone: function() {
                    if (!this.bone) return;
                    
                    // Store original transform
                    const pos = this.el.object3D.position.clone();
                    const rot = this.el.object3D.rotation.clone();
                    const scale = this.el.object3D.scale.clone();
                    
                    // Remove from original parent
                    if (this.originalParent) {
                        this.originalParent.remove(this.el.object3D);
                    }
                    
                    // Add to bone
                    this.bone.add(this.el.object3D);
                    
                    // Apply offset and rotation
                    this.el.object3D.position.set(
                        this.data.offset.x,
                        this.data.offset.y,
                        this.data.offset.z
                    );
                    
                    this.el.object3D.rotation.set(
                        THREE.MathUtils.degToRad(this.data.rotation.x),
                        THREE.MathUtils.degToRad(this.data.rotation.y),
                        THREE.MathUtils.degToRad(this.data.rotation.z)
                    );
                    
                    this.el.object3D.scale.copy(scale);
                    
                    State.boneAttached = true;
                    showToast('‚úì Gun attached to hand');
                    
                    // Make gun visible
                    if (Elements.gunModel) {
                        Elements.gunModel.setAttribute('visible', 'true');
                    }
                },
                
                tick: function () {
                    if (this.bone) {
                        this.bone.updateMatrixWorld(true);
                    }
                }
            });
            
            // ============== CAMERA FOLLOW COMPONENT (Enhanced smooth follow) ==============
            AFRAME.registerComponent('camera-follow', {
                schema: {
                    target: { type: 'selector' },
                    offset: { type: 'vec3', default: CONFIG.CAMERA_OFFSET },
                    smoothness: { type: 'number', default: CONFIG.CAMERA_SMOOTHING },
                    followRotation: { type: 'boolean', default: false }
                },
                
                init: function () {
                    this.targetPos = new THREE.Vector3();
                    this.cameraPos = new THREE.Vector3();
                    this.tempVec = new THREE.Vector3();
                },
                
                tick: function () {
                    if (!this.data.target) return;
                    
                    // Get target world position
                    this.targetPos.setFromMatrixPosition(this.data.target.object3D.matrixWorld);
                    
                    // Calculate desired camera position (target + offset)
                    this.tempVec.copy(this.targetPos).add(this.data.offset);
                    
                    // Get current camera position
                    this.cameraPos.copy(this.el.object3D.position);
                    
                    // Smooth interpolation
                    this.cameraPos.lerp(this.tempVec, this.data.smoothness);
                    
                    // Apply position
                    this.el.object3D.position.copy(this.cameraPos);
                    
                    // Make camera look at target with smooth rotation
                    if (!this.data.followRotation) {
                        this.el.object3D.lookAt(this.targetPos);
                    }
                }
            });
            
            // ============== GROUND DETECTION SYSTEM ==============
            function checkGrounded() {
                if (!Elements.player || !Elements.scene) return true;
                
                try {
                    const playerPos = Elements.player.object3D.position;
                    
                    // Simple ground check based on Y position
                    // In a full implementation, you'd use raycasting here
                    const grounded = playerPos.y <= State.groundLevel + 0.02;
                    
                    if (!grounded && !State.isJumping) {
                        // Apply gravity
                        playerPos.y -= 0.005;
                        if (playerPos.y < State.groundLevel) {
                            playerPos.y = State.groundLevel;
                        }
                        Elements.player.object3D.position.copy(playerPos);
                    }
                    
                    return grounded;
                } catch (e) {
                    return true;
                }
            }
            
            // ============== ANIMATION SYSTEM (Enhanced) ==============
            function setAnimation(animName) {
                if (!Elements.playerModel) return;
                
                // Update UI
                let displayName = animName.toUpperCase();
                if (animName === 'idle') displayName = 'IDLE';
                else if (animName.includes('run')) displayName = 'üèÉ RUNNING';
                else if (animName.includes('walk')) displayName = 'üö∂ WALKING';
                else if (animName.includes('shoot')) displayName = 'üî´ SHOOTING';
                else if (animName === 'jump') displayName = 'ü¶ò JUMP';
                else if (animName === 'throw-grenade') displayName = 'üí£ GRENADE';
                else if (animName.includes('hit')) displayName = 'üí• HIT';
                
                if (DOM.animStatus) {
                    DOM.animStatus.textContent = displayName;
                }
                
                State.currentAnimation = animName;
                
                // Check if animation exists in model
                const mixer = Elements.playerModel.components['animation-mixer'];
                if (mixer && mixer.clips && !mixer.clips.find(c => c.name === animName)) {
                    console.warn(`Animation "${animName}" not found in model, using idle`);
                    animName = 'idle';
                }
                
                // Set animation
                Elements.playerModel.setAttribute('animation-mixer', {
                    clip: animName,
                    loop: (animName.includes('hit') || animName === 'jump' || 
                           animName.includes('shoot') || animName === 'throw-grenade' || 
                           animName === 'reloading') ? 'once' : 'repeat',
                    timeScale: 1.0,
                    crossFadeDuration: 0.2
                });
                
                // Handle one-shot animations
                if (animName.includes('hit') || animName === 'jump' || 
                    animName.includes('shoot') || animName === 'throw-grenade' || 
                    animName === 'reloading') {
                    
                    const duration = CONFIG.ANIMATION_DEFAULTS[animName] || 500;
                    
                    setTimeout(() => {
                        if (!State.joystickActive && !State.isJumping) {
                            setAnimation('idle');
                        } else if (State.joystickActive && !State.isJumping) {
                            updateMovementAnimation();
                        }
                    }, duration);
                }
            }
            
            function updateMovementAnimation() {
                if (State.isJumping) return;
                
                const timeSinceLastMove = Date.now() - State.lastMovementTime;
                
                if (!State.joystickActive || timeSinceLastMove > State.movementThreshold) {
                    if (State.currentAnimation !== 'idle') {
                        setAnimation('idle');
                    }
                    return;
                }
                
                const magnitude = Math.sqrt(State.joystickVector.x * State.joystickVector.x + 
                                           State.joystickVector.y * State.joystickVector.y);
                const isRunning = magnitude > 0.7;
                
                // Determine direction
                if (Math.abs(State.joystickVector.x) > Math.abs(State.joystickVector.y)) {
                    // Strafe
                    if (State.joystickVector.x > 0) {
                        setAnimation(isRunning ? 'run-right' : 'walk-right');
                    } else {
                        setAnimation(isRunning ? 'run-left' : 'walk-left');
                    }
                } else {
                    // Forward/backward
                    if (State.joystickVector.y > 0) {
                        setAnimation(isRunning ? 'run-forward' : 'walk-forward');
                    } else {
                        setAnimation(isRunning ? 'run-backwards' : 'walk-backwards');
                    }
                }
            }
            
            // ============== JUMP FUNCTION (Enhanced with physics) ==============
            function jump() {
                if (State.isJumping) return;
                
                const grounded = checkGrounded();
                if (!grounded) return;
                
                State.isJumping = true;
                setAnimation('jump');
                
                const startY = Elements.player.object3D.position.y;
                const jumpStartTime = Date.now();
                
                function jumpAnimation() {
                    if (!Elements.player) return;
                    
                    const elapsed = Date.now() - jumpStartTime;
                    const progress = Math.min(elapsed / CONFIG.JUMP_DURATION, 1);
                    
                    if (progress >= 1) {
                        // Jump complete
                        const pos = Elements.player.object3D.position;
                        pos.y = State.groundLevel;
                        Elements.player.object3D.position.copy(pos);
                        State.isJumping = false;
                        updateMovementAnimation();
                        return;
                    }
                    
                    // Parabolic arc
                    const jumpProgress = Math.sin(progress * Math.PI);
                    const pos = Elements.player.object3D.position;
                    pos.y = startY + (CONFIG.JUMP_HEIGHT * jumpProgress);
                    Elements.player.object3D.position.copy(pos);
                    
                    requestAnimationFrame(jumpAnimation);
                }
                
                jumpAnimation();
            }
            
            // ============== SHOOT FUNCTION ==============
            function shoot() {
                if (State.isJumping) return;
                setAnimation('shoot-rifle');
                
                // Muzzle flash
                if (Elements.gunModel) {
                    Elements.gunModel.setAttribute('material', {
                        emissive: '#FF5500',
                        emissiveIntensity: 2.0
                    });
                    
                    setTimeout(() => {
                        if (Elements.gunModel) {
                            Elements.gunModel.setAttribute('material', {
                                emissive: '#442200',
                                emissiveIntensity: 0.5
                            });
                        }
                    }, 100);
                }
                
                // Recoil effect
                if (Elements.gunModel) {
                    const originalPos = Elements.gunModel.object3D.position.clone();
                    Elements.gunModel.object3D.position.z -= 0.002;
                    setTimeout(() => {
                        if (Elements.gunModel) {
                            Elements.gunModel.object3D.position.copy(originalPos);
                        }
                    }, 50);
                }
            }
            
            // ============== GRENADE FUNCTION ==============
            function throwGrenade() {
                if (State.isJumping) return;
                setAnimation('throw-grenade');
                
                // Visual feedback
                showToast('üí• Grenade thrown!', 1000);
            }
            
            // ============== MOVEMENT SYSTEM ==============
            function movePlayer() {
                if (!State.gameRunning || !State.joystickActive || State.isJumping || !Elements.player || !Elements.camera) {
                    return;
                }
                
                const pos = Elements.player.object3D.position;
                const rot = Elements.camera.object3D.rotation;
                
                const magnitude = Math.sqrt(State.joystickVector.x * State.joystickVector.x + 
                                           State.joystickVector.y * State.joystickVector.y);
                const currentSpeed = magnitude > 0.7 ? CONFIG.RUN_SPEED : CONFIG.WALK_SPEED;
                
                // Move relative to camera direction
                const radY = rot.y;
                
                // Forward/backward
                if (State.joystickVector.y !== 0) {
                    pos.x += Math.sin(radY) * State.joystickVector.y * currentSpeed * -1;
                    pos.z += Math.cos(radY) * State.joystickVector.y * currentSpeed * -1;
                }
                
                // Left/right strafe
                if (State.joystickVector.x !== 0) {
                    pos.x += Math.sin(radY + Math.PI/2) * State.joystickVector.x * currentSpeed;
                    pos.z += Math.cos(radY + Math.PI/2) * State.joystickVector.x * currentSpeed;
                }
                
                // Keep in bounds
                pos.x = Math.max(-90, Math.min(90, pos.x));
                pos.z = Math.max(-90, Math.min(90, pos.z));
                
                // Update position display
                if (DOM.posX) DOM.posX.textContent = Math.round(pos.x * 10) / 10;
                if (DOM.posY) DOM.posY.textContent = Math.round(pos.y * 100) / 100;
                if (DOM.posZ) DOM.posZ.textContent = Math.round(pos.z * 10) / 10;
            }
            
            // ============== JOYSTICK CONTROLS ==============
            function setupJoystick() {
                if (!DOM.moveJoystick || !DOM.joystickHandle) return;
                
                DOM.moveJoystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    State.joystickActive = true;
                    State.lastMovementTime = Date.now();
                    updateJoystick(e.touches[0]);
                });
                
                DOM.moveJoystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (State.joystickActive) {
                        State.lastMovementTime = Date.now();
                        updateJoystick(e.touches[0]);
                    }
                });
                
                DOM.moveJoystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    State.joystickActive = false;
                    State.joystickVector = { x: 0, y: 0 };
                    DOM.joystickHandle.style.transform = 'translate(0px, 0px)';
                    State.lastMovementTime = Date.now();
                });
            }
            
            function updateJoystick(touch) {
                const rect = DOM.moveJoystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const maxDistance = 40;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                DOM.joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                State.joystickVector.x = deltaX / maxDistance;
                State.joystickVector.y = deltaY / maxDistance;
            }
            
            // ============== MODEL LOADING WITH FALLBACKS ==============
            function setupModelErrorHandling() {
                if (Elements.playerModel) {
                    Elements.playerModel.addEventListener('error', (e) => {
                        console.error('Failed to load Player.glb, using fallback');
                        updateLoadingStatus('‚ö†Ô∏è Player model failed, using fallback...');
                        
                        // Try fallback model
                        Elements.playerModel.setAttribute('src', '#fallback-player');
                        
                        // If that also fails, create primitive fallback
                        setTimeout(() => {
                            if (!State.modelsLoaded.player) {
                                createPlayerFallback();
                            }
                        }, 3000);
                    });
                    
                    Elements.playerModel.addEventListener('loaded', () => {
                        console.log('Player model loaded successfully');
                        State.modelsLoaded.player = true;
                        updateLoadingStatus('‚úì Player model loaded');
                        
                        // List available animations
                        const mixer = Elements.playerModel.components['animation-mixer'];
                        if (mixer && mixer.clips) {
                            mixer.clips.forEach(clip => {
                                State.animationClips.add(clip.name);
                                console.log('Animation available:', clip.name);
                            });
                        }
                        
                        checkAllModelsLoaded();
                    });
                }
                
                if (Elements.gunModel) {
                    Elements.gunModel.addEventListener('error', (e) => {
                        console.error('Failed to load Mpsd.glb, using primitive fallback');
                        updateLoadingStatus('‚ö†Ô∏è Gun model failed, using fallback...');
                        
                        // Create primitive gun as fallback
                        setTimeout(() => {
                            if (!State.modelsLoaded.gun) {
                                createGunFallback();
                            }
                        }, 1000);
                    });
                    
                    Elements.gunModel.addEventListener('loaded', () => {
                        console.log('Gun model loaded successfully');
                        State.modelsLoaded.gun = true;
                        updateLoadingStatus('‚úì Gun model loaded');
                        checkAllModelsLoaded();
                    });
                }
            }
            
            function createPlayerFallback() {
                console.log('Creating player fallback');
                if (!Elements.player) return;
                
                // Create a simple character from primitives
                const fallbackGroup = document.createElement('a-entity');
                fallbackGroup.setAttribute('position', '0 0 0');
                
                // Body
                const body = document.createElement('a-box');
                body.setAttribute('width', '0.02');
                body.setAttribute('height', '0.04');
                body.setAttribute('depth', '0.02');
                body.setAttribute('color', '#44AAFF');
                body.setAttribute('position', '0 0.02 0');
                body.setAttribute('shadow', '');
                fallbackGroup.appendChild(body);
                
                // Head
                const head = document.createElement('a-sphere');
                head.setAttribute('radius', '0.012');
                head.setAttribute('color', '#FFDDAA');
                head.setAttribute('position', '0 0.05 0');
                head.setAttribute('shadow', '');
                fallbackGroup.appendChild(head);
                
                // Arms
                const leftArm = document.createElement('a-box');
                leftArm.setAttribute('width', '0.01');
                leftArm.setAttribute('height', '0.02');
                leftArm.setAttribute('depth', '0.01');
                leftArm.setAttribute('color', '#44AAFF');
                leftArm.setAttribute('position', '-0.015 0.03 0');
                leftArm.setAttribute('rotation', '0 0 10');
                fallbackGroup.appendChild(leftArm);
                
                const rightArm = document.createElement('a-box');
                rightArm.setAttribute('width', '0.01');
                rightArm.setAttribute('height', '0.02');
                rightArm.setAttribute('depth', '0.01');
                rightArm.setAttribute('color', '#44AAFF');
                rightArm.setAttribute('position', '0.015 0.03 0');
                rightArm.setAttribute('rotation', '0 0 -10');
                fallbackGroup.appendChild(rightArm);
                
                Elements.playerModel.parentNode.appendChild(fallbackGroup);
                Elements.playerModel.setAttribute('visible', 'false');
                
                State.modelsLoaded.player = true;
                showToast('Using fallback player model');
                checkAllModelsLoaded();
            }
            
            function createGunFallback() {
                console.log('Creating gun fallback');
                if (!Elements.gunHolder) return;
                
                const fallbackGun = document.createElement('a-entity');
                fallbackGun.setAttribute('scale', '0.0025 0.0025 0.0025');
                fallbackGun.setAttribute('position', '0.01 0.005 0.005');
                fallbackGun.setAttribute('rotation', '0 90 0');
                
                // Gun body
                const body = document.createElement('a-box');
                body.setAttribute('width', '0.5');
                body.setAttribute('height', '0.15');
                body.setAttribute('depth', '0.3');
                body.setAttribute('color', '#444444');
                body.setAttribute('position', '0 0 0');
                fallbackGun.appendChild(body);
                
                // Barrel
                const barrel = document.createElement('a-cylinder');
                barrel.setAttribute('radius', '0.05');
                barrel.setAttribute('height', '0.6');
                barrel.setAttribute('color', '#666666');
                barrel.setAttribute('position', '0.3 0 0');
                barrel.setAttribute('rotation', '0 0 90');
                fallbackGun.appendChild(barrel);
                
                // Handle
                const handle = document.createElement('a-box');
                handle.setAttribute('width', '0.15');
                handle.setAttribute('height', '0.3');
                handle.setAttribute('depth', '0.15');
                handle.setAttribute('color', '#222222');
                handle.setAttribute('position', '-0.2 -0.1 0');
                fallbackGun.appendChild(handle);
                
                Elements.gunHolder.appendChild(fallbackGun);
                Elements.gunModel.setAttribute('visible', 'false');
                
                State.modelsLoaded.gun = true;
                showToast('Using fallback gun model');
                checkAllModelsLoaded();
            }
            
            function checkAllModelsLoaded() {
                if (State.modelsLoaded.player && State.modelsLoaded.gun) {
                    setTimeout(() => {
                        hideLoadingScreen();
                        State.loadingComplete = true;
                        showToast('‚ú® World ready!', 2000);
                        
                        // Attach gun to bone
                        if (Elements.gunHolder && Elements.playerModel) {
                            Elements.gunHolder.setAttribute('enhanced-bone-constraint', {
                                target: '#player-model-instance',
                                boneNames: CONFIG.BONE_NAMES,
                                offset: { x: 0.01, y: 0.005, z: 0.005 },
                                rotation: { x: 0, y: 90, z: 0 }
                            });
                        }
                    }, 500);
                }
            }
            
            // ============== GAME LOOP ==============
            function gameLoop() {
                if (State.gameRunning) {
                    movePlayer();
                    checkGrounded();
                    updateMovementAnimation();
                }
                requestAnimationFrame(gameLoop);
            }
            
            // ============== EVENT LISTENERS ==============
            function setupEventListeners() {
                // Touch buttons
                if (DOM.jumpBtn) {
                    DOM.jumpBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        jump();
                    });
                }
                
                if (DOM.shootBtn) {
                    DOM.shootBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        shoot();
                    });
                }
                
                if (DOM.grenadeBtn) {
                    DOM.grenadeBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        throwGrenade();
                    });
                }
                
                // Keyboard controls (for debugging)
                window.addEventListener('keydown', (e) => {
                    if (!State.gameRunning) return;
                    
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            jump();
                            break;
                        case 'f':
                        case 'F':
                            shoot();
                            break;
                        case 'g':
                        case 'G':
                            throwGrenade();
                            break;
                    }
                });
                
                // Prevent default touch behaviors
                document.addEventListener('touchmove', (e) => {
                    if (e.target.closest('#touch-controls')) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            
            // ============== INITIALIZATION ==============
            function init() {
                console.log('Initializing Mini World Explorer...');
                updateLoadingStatus('Initializing...');
                
                // Get A-Frame elements
                Elements.scene = document.querySelector('a-scene');
                Elements.camera = document.getElementById('camera');
                Elements.player = document.getElementById('player');
                Elements.playerModel = document.getElementById('player-model-instance');
                Elements.gunHolder = document.getElementById('gun-holder');
                Elements.gunModel = document.getElementById('gun-model-instance');
                Elements.followRig = document.getElementById('camera-follow-rig');
                Elements.cameraRig = document.getElementById('camera-rig');
                
                // Set up camera follow system
                if (Elements.followRig && Elements.player) {
                    // The follow rig will handle camera positioning
                    // Camera is parented to follow rig which follows player
                }
                
                // Set initial player position
                if (Elements.player) {
                    Elements.player.object3D.position.set(0, State.groundLevel, 0);
                }
                
                // Setup systems
                setupJoystick();
                setupModelErrorHandling();
                setupEventListeners();
                
                // Start game loop when scene loads
                if (Elements.scene) {
                    Elements.scene.addEventListener('loaded', () => {
                        console.log('Scene loaded');
                        
                        // Set up camera follow using AFRAME components
                        if (Elements.cameraRig && Elements.player) {
                            // Use AFRAME's built-in components for smooth follow
                            Elements.cameraRig.setAttribute('position', CONFIG.CAMERA_OFFSET);
                            
                            // In the game loop, we'll handle the follow logic
                        }
                        
                        setTimeout(() => {
                            setAnimation('idle');
                            showToast('Use joystick to move', 3000);
                        }, 1500);
                        
                        gameLoop();
                    });
                }
            }
            
            // Start when DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>
