<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Free Fire Style Action Game - A-Frame (5x Smaller, 3rd Person Camera)</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-physics-system@4.0.2/dist/aframe-physics-system.min.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        /* Mobile touch controls styling */
        #touch-controls {
            position: fixed;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 20px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .joystick-area {
            pointer-events: auto;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 60px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }
        
        .joystick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 25px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 35px;
            background: rgba(255, 0, 0, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.8);
            color: white;
            font-size: 16px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
            cursor: pointer;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(200, 0, 0, 0.9);
        }
        
        #jump-btn {
            background: rgba(0, 150, 255, 0.7);
        }
        
        #jump-btn:active {
            background: rgba(0, 100, 200, 0.9);
        }
        
        #shoot-btn {
            background: rgba(255, 50, 50, 0.9);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* UI Elements */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 2px black;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        
        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 2000;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        #restart-btn {
            padding: 10px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 20px;
            cursor: pointer;
        }
        
        /* Mini-map style indicator */
        #debug-info {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- HUD Display -->
    <div id="hud">
        <div>Health: <span id="health">100</span></div>
        <div>Score: <span id="score">0</span></div>
        <div id="enemies-left">Enemies: 5</div>
    </div>
    
    <!-- Debug Info -->
    <div id="debug-info">3rd Person Camera - 5x Smaller Characters</div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <h1 id="game-over-text">GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Play Again</button>
    </div>
    
    <!-- Mobile Touch Controls -->
    <div id="touch-controls">
        <div class="joystick-area" id="move-joystick">
            <div class="joystick" id="joystick-handle"></div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" id="jump-btn">JUMP</button>
            <button class="action-btn" id="shoot-btn">SHOOT</button>
        </div>
    </div>
    
    <!-- A-Frame Scene -->
    <a-scene physics="gravity: -9.8;" background="color: #87CEEB">
        <!-- Assets -->
        <a-assets>
            <!-- Player Character - Now 5x smaller (0.5/5 = 0.1) -->
            <a-asset-item id="player-model" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/RobotExpressive/RobotExpressive.glb"></a-asset-item>
            
            <!-- Enemy Character - Now 5x smaller -->
            <a-asset-item id="enemy-model" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/RobotExpressive/RobotExpressive.glb"></a-asset-item>
        </a-assets>
        
        <!-- Third Person Camera Rig - Positioned behind and above player -->
        <a-entity id="camera-rig" position="0 0.5 0">
            <!-- The player model (visible in 3rd person) -->
            <a-entity id="player" position="0 0 0">
                <a-gltf-model src="#player-model" scale="0.1 0.1 0.1" position="0 0 0" animation-mixer></a-gltf-model>
            </a-entity>
            
            <!-- Camera positioned behind player (like in the image) -->
            <a-camera id="camera" wasd-controls="enabled: false" look-controls="enabled: true" position="0 1.2 2.5" rotation="0 0 0"></a-camera>
        </a-entity>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#fff" intensity="0.5"></a-light>
        <a-light type="directional" position="1 2 1" intensity="1.5" castshadow="true"></a-light>
        <a-light type="point" position="0 5 0" intensity="1"></a-light>
        
        <!-- Ground with texture pattern - Adjusted size for smaller characters -->
        <a-plane id="ground" rotation="-90 0 0" width="80" height="80" color="#4CAF50" material="side: double; roughness: 0.8; metalness: 0.2; repeat: 12 12" static-body></a-plane>
        
        <!-- Grid for scale reference -->
        <a-grid position="0 0.02 0" width="80" height="80" cell-size="1" material="color: #333; opacity: 0.3"></a-grid>
        
        <!-- Obstacles / Cover - Proportional to 5x smaller characters -->
        <!-- Low walls -->
        <a-box position="-5 0.1 -5" width="2" height="0.2" depth="2" color="#8B4513" static-body></a-box>
        <a-box position="5 0.1 -8" width="2" height="0.2" depth="2" color="#8B4513" static-body></a-box>
        <a-box position="-2 0.1 -12" width="3" height="0.2" depth="3" color="#8B4513" static-body></a-box>
        <a-box position="3 0.1 -15" width="2" height="0.2" depth="2" color="#8B4513" static-body></a-box>
        
        <!-- Tall obstacles for cover -->
        <a-box position="-8 0.45 -8" width="1.8" height="0.9" depth="1.8" color="#A0522D" static-body></a-box>
        <a-box position="7 0.45 -10" width="1.8" height="0.9" depth="1.8" color="#A0522D" static-body></a-box>
        <a-box position="0 0.45 -20" width="2.2" height="0.9" depth="2.2" color="#A0522D" static-body></a-box>
        
        <!-- Trees / Decoration - Scaled for 5x smaller world -->
        <a-cylinder position="-7 0 -10" radius="0.2" height="1.0" color="#8B4513" static-body></a-cylinder>
        <a-sphere position="-7 0.6 -10" radius="0.4" color="green"></a-sphere>
        
        <a-cylinder position="8 0 -12" radius="0.2" height="1.0" color="#8B4513" static-body></a-cylinder>
        <a-sphere position="8 0.6 -12" radius="0.4" color="green"></a-sphere>
        
        <!-- Bushes -->
        <a-sphere position="-4 0.15 -7" radius="0.25" color="darkgreen"></a-sphere>
        <a-sphere position="6 0.15 -15" radius="0.25" color="darkgreen"></a-sphere>
        
        <!-- Rocks -->
        <a-sphere position="-3 0.1 -20" radius="0.2" color="gray" roughness="0.8"></a-sphere>
        <a-sphere position="4 0.1 -22" radius="0.25" color="gray" roughness="0.8"></a-sphere>
        
        <!-- Barrels for cover -->
        <a-cylinder position="-6 0.15 -14" radius="0.15" height="0.3" color="#CD853F" static-body></a-cylinder>
        <a-cylinder position="9 0.15 -17" radius="0.15" height="0.3" color="#CD853F" static-body></a-cylinder>
        
        <!-- Crates -->
        <a-box position="-1 0.15 -18" width="0.4" height="0.3" depth="0.4" color="#D2691E" static-body></a-box>
        <a-box position="2 0.15 -19" width="0.4" height="0.3" depth="0.4" color="#D2691E" static-body></a-box>
    </a-scene>
    
    <script>
        // Game State
        let gameRunning = true;
        let playerHealth = 100;
        let playerScore = 0;
        let enemies = [];
        let bullets = [];
        // Adjusted move speed for 5x smaller world
        let moveSpeed = 0.08;
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        
        // DOM Elements
        const healthEl = document.getElementById('health');
        const scoreEl = document.getElementById('score');
        const enemiesLeftEl = document.getElementById('enemies-left');
        const gameOverDiv = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        
        // Touch Controls
        const moveJoystick = document.getElementById('move-joystick');
        const joystickHandle = document.getElementById('joystick-handle');
        const jumpBtn = document.getElementById('jump-btn');
        const shootBtn = document.getElementById('shoot-btn');
        
        // A-Frame Elements
        const scene = document.querySelector('a-scene');
        const cameraRig = document.getElementById('camera-rig');
        const camera = document.getElementById('camera');
        const player = document.getElementById('player');
        
        // Joystick Logic
        moveJoystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            updateJoystick(e.touches[0]);
        });
        
        moveJoystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                updateJoystick(e.touches[0]);
            }
        });
        
        moveJoystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            joystickHandle.style.transform = 'translate(0px, 0px)';
        });
        
        function updateJoystick(touch) {
            const rect = moveJoystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            
            // Limit to joystick radius
            const maxDistance = 40;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            
            // Normalize vector (-1 to 1)
            joystickVector.x = deltaX / maxDistance;
            joystickVector.y = deltaY / maxDistance;
        }
        
        // Action Buttons
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) {
                jump();
            }
        });
        
        shootBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) {
                shoot();
            }
        });
        
        // Jump Function - Adjusted for 5x smaller scale
        function jump() {
            let pos = cameraRig.getAttribute('position');
            if (pos.y <= 0.55) { // Ground level check
                pos.y += 0.5; // Jump height
                cameraRig.setAttribute('position', pos);
                
                // Gravity pull down
                setTimeout(() => {
                    let newPos = cameraRig.getAttribute('position');
                    newPos.y -= 0.5;
                    cameraRig.setAttribute('position', newPos);
                }, 250);
            }
        }
        
        // Shoot Function
        function shoot() {
            if (!gameRunning) return;
            
            // Create bullet
            const bullet = document.createElement('a-sphere');
            bullet.setAttribute('radius', '0.08');
            bullet.setAttribute('color', 'red');
            bullet.setAttribute('dynamic-body', '');
            
            // Get camera position and direction
            const cameraPos = camera.getAttribute('position');
            const cameraRot = camera.getAttribute('rotation');
            
            // Calculate bullet direction based on camera rotation
            const radY = THREE.MathUtils.degToRad(cameraRot.y);
            const direction = {
                x: -Math.sin(radY),
                z: -Math.cos(radY)
            };
            
            // Get world position of camera relative to rig
            const rigPos = cameraRig.getAttribute('position');
            
            bullet.setAttribute('position', {
                x: rigPos.x + cameraPos.x + direction.x,
                y: rigPos.y + cameraPos.y - 0.1,
                z: rigPos.z + cameraPos.z + direction.z
            });
            
            scene.appendChild(bullet);
            
            // Store bullet data
            bullets.push({
                element: bullet,
                direction: direction,
                speed: 0.3
            });
            
            // Visual feedback - muzzle flash
            const flash = document.createElement('a-sphere');
            flash.setAttribute('radius', '0.05');
            flash.setAttribute('color', 'yellow');
            flash.setAttribute('position', {
                x: rigPos.x + cameraPos.x + direction.x,
                y: rigPos.y + cameraPos.y - 0.1,
                z: rigPos.z + cameraPos.z + direction.z
            });
            scene.appendChild(flash);
            setTimeout(() => flash.remove(), 50);
        }
        
        // Move player based on joystick
        function movePlayer() {
            if (!gameRunning || !joystickActive) return;
            
            const pos = cameraRig.getAttribute('position');
            const rot = camera.getAttribute('rotation');
            
            // Move relative to camera direction
            const radY = THREE.MathUtils.degToRad(rot.y);
            
            // Forward/backward movement
            if (joystickVector.y !== 0) {
                pos.x += Math.sin(radY) * joystickVector.y * moveSpeed * -1;
                pos.z += Math.cos(radY) * joystickVector.y * moveSpeed * -1;
            }
            
            // Left/right movement (strafe)
            if (joystickVector.x !== 0) {
                pos.x += Math.sin(radY + Math.PI/2) * joystickVector.x * moveSpeed;
                pos.z += Math.cos(radY + Math.PI/2) * joystickVector.x * moveSpeed;
            }
            
            // Keep player within bounds
            pos.x = Math.max(-35, Math.min(35, pos.x));
            pos.z = Math.max(-35, Math.min(35, pos.z));
            
            cameraRig.setAttribute('position', pos);
        }
        
        // Create enemies - Now 5x smaller
        function createEnemies(count) {
            for (let i = 0; i < count; i++) {
                const enemy = document.createElement('a-entity');
                enemy.setAttribute('class', 'enemy');
                
                // Random position
                const angle = (i / count) * Math.PI * 2;
                const distance = 8 + Math.random() * 6;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance - 10;
                
                enemy.setAttribute('position', { x, y: 0, z });
                
                // Enemy model - 5x smaller (0.5/5 = 0.1)
                const model = document.createElement('a-gltf-model');
                model.setAttribute('src', '#enemy-model');
                model.setAttribute('scale', '0.1 0.1 0.1');
                model.setAttribute('animation-mixer', '');
                enemy.appendChild(model);
                
                // Health bar - proportional
                const healthBar = document.createElement('a-plane');
                healthBar.setAttribute('class', 'enemy-health');
                healthBar.setAttribute('width', '0.8');
                healthBar.setAttribute('height', '0.08');
                healthBar.setAttribute('color', 'red');
                healthBar.setAttribute('position', '0 0.6 0');
                enemy.appendChild(healthBar);
                
                scene.appendChild(enemy);
                
                enemies.push({
                    element: enemy,
                    health: 30,
                    maxHealth: 30,
                    speed: 0.015,
                    lastShot: 0
                });
            }
            
            enemiesLeftEl.textContent = `Enemies: ${enemies.length}`;
        }
        
        // Enemy AI
        function updateEnemies() {
            if (!gameRunning) return;
            
            const playerPos = cameraRig.getAttribute('position');
            
            enemies.forEach((enemy, index) => {
                const enemyPos = enemy.element.getAttribute('position');
                
                // Move towards player
                const dx = playerPos.x - enemyPos.x;
                const dz = playerPos.z - enemyPos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                
                if (dist > 1.0) {
                    enemyPos.x += (dx / dist) * enemy.speed;
                    enemyPos.z += (dz / dist) * enemy.speed;
                    enemy.element.setAttribute('position', enemyPos);
                }
                
                // Attack
                if (dist < 1.2 && Date.now() - enemy.lastShot > 1800) {
                    enemy.lastShot = Date.now();
                    playerHealth -= 8;
                    healthEl.textContent = playerHealth;
                    
                    if (playerHealth <= 0) {
                        gameOver('You Died!');
                    }
                    
                    // Attack visual
                    const attack = document.createElement('a-sphere');
                    attack.setAttribute('radius', '0.1');
                    attack.setAttribute('color', 'orange');
                    attack.setAttribute('position', enemyPos);
                    scene.appendChild(attack);
                    setTimeout(() => attack.remove(), 150);
                }
                
                // Update health bar
                const healthBar = enemy.element.querySelector('.enemy-health');
                if (healthBar) {
                    const healthPercent = enemy.health / enemy.maxHealth;
                    healthBar.setAttribute('width', 0.8 * healthPercent);
                    healthBar.setAttribute('position', `${-(0.4 - (0.4 * healthPercent))} 0.6 0`);
                }
            });
        }
        
        // Update bullets
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                const pos = bullet.element.getAttribute('position');
                
                // Move bullet
                pos.x += bullet.direction.x * bullet.speed;
                pos.z += bullet.direction.z * bullet.speed;
                bullet.element.setAttribute('position', pos);
                
                // Check collision with enemies
                let hit = false;
                enemies.forEach((enemy, enemyIndex) => {
                    const enemyPos = enemy.element.getAttribute('position');
                    const dist = Math.sqrt(
                        Math.pow(pos.x - enemyPos.x, 2) + 
                        Math.pow(pos.z - enemyPos.z, 2)
                    );
                    
                    if (dist < 0.6) {
                        hit = true;
                        enemy.health -= 20;
                        
                        // Hit effect
                        const hitEffect = document.createElement('a-sphere');
                        hitEffect.setAttribute('radius', '0.15');
                        hitEffect.setAttribute('color', 'yellow');
                        hitEffect.setAttribute('position', enemyPos);
                        scene.appendChild(hitEffect);
                        setTimeout(() => hitEffect.remove(), 100);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            enemy.element.remove();
                            enemies.splice(enemyIndex, 1);
                            playerScore += 100;
                            scoreEl.textContent = playerScore;
                            enemiesLeftEl.textContent = `Enemies: ${enemies.length}`;
                            
                            // Victory check
                            if (enemies.length === 0) {
                                gameOver('VICTORY!', true);
                            }
                        }
                    }
                });
                
                if (hit || Math.abs(pos.x) > 40 || Math.abs(pos.z) > 40) {
                    bullet.element.remove();
                    return false;
                }
                
                return true;
            });
        }
        
        // Game Over
        function gameOver(message, victory = false) {
            gameRunning = false;
            gameOverDiv.style.display = 'block';
            document.getElementById('game-over-text').textContent = message;
            finalScoreEl.textContent = playerScore;
            
            if (victory) {
                gameOverDiv.style.background = 'rgba(0, 100, 0, 0.8)';
            } else {
                gameOverDiv.style.background = 'rgba(100, 0, 0, 0.8)';
            }
        }
        
        // Restart Game
        function restartGame() {
            // Reset game state
            gameRunning = true;
            playerHealth = 100;
            playerScore = 0;
            healthEl.textContent = playerHealth;
            scoreEl.textContent = playerScore;
            
            // Remove all enemies
            enemies.forEach(enemy => enemy.element.remove());
            enemies = [];
            
            // Remove all bullets
            bullets.forEach(bullet => bullet.element.remove());
            bullets = [];
            
            // Reset player position
            cameraRig.setAttribute('position', { x: 0, y: 0.5, z: 0 });
            
            // Reset camera rotation
            camera.setAttribute('rotation', { x: 0, y: 0, z: 0 });
            
            // Hide game over screen
            gameOverDiv.style.display = 'none';
            
            // Create new enemies
            createEnemies(5);
        }
        
        restartBtn.addEventListener('click', restartGame);
        
        // Game Loop
        function gameLoop() {
            if (gameRunning) {
                movePlayer();
                updateEnemies();
                updateBullets();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game when scene loads
        scene.addEventListener('loaded', () => {
            console.log('Scene loaded - 5x smaller characters, 3rd person camera');
            createEnemies(5);
            gameLoop();
        });
        
        // Keyboard controls for debugging
        window.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    jump();
                    break;
                case 'f':
                case 'F':
                    shoot();
                    break;
            }
        });
        
        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
    </html>
